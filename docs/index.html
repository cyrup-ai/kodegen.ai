<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KODEGEN.·¥Ä…™ - Documentation</title>
    <link rel="icon" type="image/x-icon" href="../assets/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="../assets/favicon/iphone-app-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="76x76" href="../assets/favicon/ipad-app-icon-76x76.png">
    <link rel="icon" type="image/png" sizes="152x152" href="../assets/favicon/ipad-app-icon-152x152.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Fira Code', monospace;
            color: #ffffff;
            background: #051226;
            line-height: 1.6;
        }

        .header {
            background: linear-gradient(to bottom, #0a1929 0%, #051226 100%);
            padding: 0;
            text-align: center;
            border-bottom: 2px solid rgba(24, 202, 155, 0.3);
        }

        .kodegen-logo {
            width: 100%;
            height: auto;
            margin: 0;
            display: block;
        }

        .header-content {
            padding: 2rem;
        }

        .header h1 {
            font-size: 2rem;
            color: #18ca9b;
            margin-bottom: 0.5rem;
        }

        .header p {
            color: #CCCCCC;
            font-size: 0.9rem;
        }

        .header a {
            color: #18ca9b;
            text-decoration: none;
        }

        .header a:hover {
            text-decoration: underline;
        }

        .hero-section {
            background: #051226;
            padding: 0;
            text-align: center;
        }

        .kodegen-video {
            width: 100%;
            height: auto;
            margin-bottom: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 3rem;
        }

        .sidebar {
            position: sticky;
            top: 20px;
            height: fit-content;
        }

        .sidebar nav {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(24, 202, 155, 0.2);
            border-radius: 8px;
            padding: 1.5rem;
        }

        .sidebar h3 {
            color: #18ca9b;
            font-size: 0.9rem;
            margin-bottom: 1rem;
            text-transform: uppercase;
        }

        .sidebar ul {
            list-style: none;
        }

        .sidebar li {
            margin-bottom: 0.75rem;
        }

        .sidebar a {
            color: #CCCCCC;
            text-decoration: none;
            font-size: 0.85rem;
            transition: color 0.3s ease;
        }

        .sidebar a:hover {
            color: #18ca9b;
        }

        .content {
            min-width: 0;
        }

        .section {
            margin-bottom: 4rem;
        }

        .section h2 {
            color: #18ca9b;
            font-size: 1.8rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid rgba(24, 202, 155, 0.3);
        }

        .section h3 {
            color: #18ca9b;
            font-size: 1.3rem;
            margin-top: 2rem;
            margin-bottom: 1rem;
        }

        .section h4 {
            color: #18ca9b;
            font-size: 1.1rem;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        .section p {
            color: #CCCCCC;
            margin-bottom: 1rem;
        }

        .section ul, .section ol {
            color: #CCCCCC;
            margin-left: 2rem;
            margin-bottom: 1rem;
        }

        .section li {
            margin-bottom: 0.5rem;
        }

        code {
            background: rgba(0, 0, 0, 0.3);
            color: #18ca9b;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.9em;
        }

        pre {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(24, 202, 155, 0.3);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            overflow-x: auto;
        }

        pre code {
            background: none;
            padding: 0;
            display: block;
            white-space: pre;
        }

        .tool-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .tool-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(24, 202, 155, 0.2);
            border-radius: 8px;
            padding: 1.5rem;
            transition: all 0.3s ease;
        }

        .tool-card:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(24, 202, 155, 0.4);
        }

        .tool-card h4 {
            color: #18ca9b;
            margin-top: 0;
            margin-bottom: 0.5rem;
        }

        .tool-card p {
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
        }

        .tool-card .params {
            font-size: 0.75rem;
            color: #999;
        }

        .badge {
            display: inline-block;
            background: rgba(24, 202, 155, 0.2);
            color: #18ca9b;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-size: 0.75rem;
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .footer {
            background: #051226;
            padding: 2rem;
            text-align: center;
            color: #CCCCCC;
            border-top: 2px solid rgba(24, 202, 155, 0.3);
            margin-top: 4rem;
        }

        .footer a {
            color: #18ca9b;
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }

            .sidebar {
                position: static;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .section h2 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <img src="../assets/banner.png" alt="KODEGEN.·¥Ä…™" class="kodegen-logo">
        <div class="header-content">
            <p>Documentation ‚Ä¢ <a href="../index.html">‚Üê Back to Home</a></p>
        </div>
    </div>

    <div class="container">
        <aside class="sidebar">
            <nav>
                <h3>Contents</h3>
                <ul>
                    <li><a href="#overview">Overview</a></li>
                    <li><a href="#installation">Installation</a></li>
                    <li><a href="#configuration">Configuration</a></li>
                    <li><a href="#advanced">Advanced Users</a></li>
                    <li><a href="#tools">Tool Reference</a></li>
                    <li><a href="#examples">Examples</a></li>
                    <li><a href="#contributing">Contributing</a></li>
                </ul>
            </nav>
        </aside>

        <main class="content">
            <section id="overview" class="section">
                <h2>Overview</h2>
                <p>KODEGEN.·¥Ä…™ is a blazing-fast Rust-native MCP Server (Model Context Protocol) with 75 elite auto-coding tools designed for professional, autonomous code generation and predictable high-quality results.</p>

                <p>Every tool has been thoughtfully hyper-optimized for:</p>
                <ul>
                    <li><strong>Speed</strong> - Code it faster with native Rust performance</li>
                    <li><strong>Context Efficiency</strong> - Code it cheaper with minimal token usage</li>
                    <li><strong>Agent-First Design</strong> - Built for AI workflows, not humans</li>
                </ul>

                <h3>Key Features</h3>
                <div class="tool-grid">
                    <div class="tool-card">
                        <h4>üóÇÔ∏è Warp Speed Mods</h4>
                        <p>14 filesystem tools optimized for coding workflows with atomic operations and concurrent traversal.</p>
                    </div>
                    <div class="tool-card">
                        <h4>üíª Terminal as a Tool</h4>
                        <p>Full VT100 pseudoterminal sessions with smart state detection and real-time output streaming.</p>
                    </div>
                    <div class="tool-card">
                        <h4>üß† Reasoning Chains</h4>
                        <p>Stateful thinking sessions with branching, revision, and unlimited context across extended problem-solving.</p>
                    </div>
                    <div class="tool-card">
                        <h4>üîÆ Agents with Agents</h4>
                        <p>N-depth agent delegation with full prompt control for hierarchical, coordinated agent pyramids.</p>
                    </div>
                    <div class="tool-card">
                        <h4>üìä LLM Observability</h4>
                        <p>Track tool usage, analyze patterns, and optimize workflows with built-in introspection.</p>
                    </div>
                    <div class="tool-card">
                        <h4>üìù Agents Manage Prompts</h4>
                        <p>Create and manage reusable prompt templates with Jinja2 rendering and schema validation.</p>
                    </div>
                </div>
            </section>

            <section id="installation" class="section">
                <h2>Installation</h2>

                <h3>Quick Install</h3>
                <p>Install KODEGEN.·¥Ä…™ with a single command:</p>
                <pre><code>curl -fsSL https://kodegen.ai/install | sh</code></pre>

                <h3>Automatic Editor Configuration</h3>
                <p>After installation, automatically configure all detected MCP clients with one command:</p>
                <pre><code>kodegen install</code></pre>

                <p>This will scan your system and automatically configure:</p>
                <div class="tool-grid">
                    <div class="tool-card">
                        <h4>‚úÖ Claude Desktop</h4>
                        <p>Auto-configures <code>claude_desktop_config.json</code></p>
                    </div>
                    <div class="tool-card">
                        <h4>‚úÖ Windsurf</h4>
                        <p>Auto-configures Windsurf MCP settings</p>
                    </div>
                    <div class="tool-card">
                        <h4>‚úÖ Cursor</h4>
                        <p>Auto-configures Cursor AI settings</p>
                    </div>
                    <div class="tool-card">
                        <h4>‚úÖ Zed</h4>
                        <p>Auto-configures Zed editor settings</p>
                    </div>
                    <div class="tool-card">
                        <h4>‚úÖ Roo Code</h4>
                        <p>Auto-configures Roo Code settings</p>
                    </div>
                </div>

                <h4>What it does:</h4>
                <ul>
                    <li>üîç Scans for installed MCP-compatible editors</li>
                    <li>üìù Creates config files if they don't exist</li>
                    <li>‚ö° Injects KODEGEN into existing configs</li>
                    <li>üíæ Creates backups before modification</li>
                    <li>‚úÖ Reports results with detailed status</li>
                </ul>

                <h3>Manual Installation</h3>
                <p>For manual installation or to build from source:</p>
                <pre><code># Clone the repository
git clone https://github.com/cyrup-ai/kodegen.git
cd kodegen

# Build with Cargo
cargo build --release

# Install to system
cargo install --path .</code></pre>

                <h3>Manual MCP Client Configuration</h3>

                <h4>Claude Desktop (Manual)</h4>
                <p>Add to your <code>~/Library/Application Support/Claude/claude_desktop_config.json</code>:</p>
                <pre><code>{
  "mcpServers": {
    "kodegen": {
      "command": "kodegen"
    }
  }
}</code></pre>

                <h4>Other MCP Clients</h4>
                <p>KODEGEN.·¥Ä…™ works with any MCP-compatible client. Use <code>kodegen install</code> for automatic configuration, or manually add the server config to:</p>
                <ul>
                    <li>Claude Code</li>
                    <li>Continue</li>
                    <li>Cline</li>
                    <li>VSCode MCP extension</li>
                    <li>And thousands more...</li>
                </ul>
            </section>

            <section id="configuration" class="section">
                <h2>Configuration</h2>

                <h3>Runtime Tool Selection</h3>
                <p>Control which tools are active at runtime by passing arguments to the kodegen binary in your MCP client configuration:</p>

                <h4>Method 1: Comma-Separated List</h4>
                <pre><code>{
  "mcpServers": {
    "kodegen": {
      "command": "kodegen",
      "args": ["--tools", "filesystem,terminal,sequential_thinking"]
    }
  }
}</code></pre>

                <h4>Method 2: Multiple Flags</h4>
                <pre><code>{
  "mcpServers": {
    "kodegen": {
      "command": "kodegen",
      "args": [
        "--tool", "filesystem",
        "--tool", "terminal",
        "--tool", "sequential_thinking"
      ]
    }
  }
}</code></pre>

                <h4>Available Tool Categories</h4>
                <ul>
                    <li><code>filesystem</code> - 14 file operation tools</li>
                    <li><code>terminal</code> - 5 terminal/process management tools</li>
                    <li><code>process</code> - 2 process management tools</li>
                    <li><code>sequential_thinking</code> - 1 reasoning chain tool</li>
                    <li><code>claude_agent</code> - 5 sub-agent orchestration tools</li>
                    <li><code>citescrape</code> - 4 web scraping and search tools</li>
                    <li><code>prompt</code> - 4 prompt template management tools</li>
                    <li><code>introspection</code> - 2 observability tools</li>
                    <li><code>git</code> - 20 git repository tools</li>
                    <li><code>github</code> - 16 GitHub API tools</li>
                    <li><code>config</code> - 2 configuration management tools</li>
                </ul>

                <p>If no arguments are provided, all compiled tool categories are enabled by default.</p>

                <h3>Runtime Configuration</h3>
                <p>AI agents can modify configuration at runtime using the <code>set_config_value</code> tool:</p>
                <pre><code>set_config_value({
  "key": "file_read_line_limit",
  "value": 5000
})</code></pre>

                <h3>Available Configuration Options</h3>

                <h4>File Operations</h4>
                <ul>
                    <li><code>file_read_line_limit</code> - Maximum lines to read per file (default: 2000)</li>
                    <li><code>file_write_line_limit</code> - Maximum lines to write per operation (default: 1000)</li>
                    <li><code>fuzzy_search_threshold</code> - Similarity threshold for fuzzy matching (default: 0.8)</li>
                </ul>

                <h4>Security</h4>
                <ul>
                    <li><code>blocked_commands</code> - List of commands to block in terminal sessions</li>
                    <li><code>allowed_paths</code> - Whitelist of paths for file operations</li>
                </ul>

                <h4>Performance</h4>
                <ul>
                    <li><code>max_search_results</code> - Maximum search results to return (default: 100)</li>
                    <li><code>terminal_timeout</code> - Terminal command timeout in seconds (default: 300)</li>
                </ul>
            </section>

            <section id="advanced" class="section">
                <h2>Advanced Users</h2>

                <h3>Custom Builds with Feature Gates</h3>
                <p>Create hyper-optimized binaries by compiling only the tools you need. KODEGEN uses Cargo feature gates to enable/disable tool categories at compile time, resulting in smaller binaries and faster startup.</p>

                <h4>Building with Specific Features</h4>
                <p>By default, all features are enabled. To build a minimal binary with only specific tools:</p>

                <pre><code># Build with only filesystem and terminal tools
cargo build --release \
  --no-default-features \
  --features "filesystem,terminal"

# Install custom build
cargo install --path . \
  --no-default-features \
  --features "filesystem,terminal,sequential_thinking"</code></pre>

                <h4>Available Feature Flags</h4>
                <div class="tool-grid">
                    <div class="tool-card">
                        <h4>filesystem</h4>
                        <p>14 tools for file operations, searching, and editing</p>
                        <span class="badge">~800KB</span>
                    </div>
                    <div class="tool-card">
                        <h4>terminal</h4>
                        <p>5 tools for terminal sessions and command execution</p>
                        <span class="badge">~300KB</span>
                    </div>
                    <div class="tool-card">
                        <h4>sequential_thinking</h4>
                        <p>1 tool for stateful reasoning chains</p>
                        <span class="badge">~150KB</span>
                    </div>
                    <div class="tool-card">
                        <h4>claude_agent</h4>
                        <p>5 tools for sub-agent orchestration</p>
                        <span class="badge">~400KB</span>
                    </div>
                    <div class="tool-card">
                        <h4>prompt</h4>
                        <p>4 tools for prompt template management</p>
                        <span class="badge">~250KB</span>
                    </div>
                    <div class="tool-card">
                        <h4>introspection</h4>
                        <p>2 tools for usage tracking and observability</p>
                        <span class="badge">~100KB</span>
                    </div>
                    <div class="tool-card">
                        <h4>process</h4>
                        <p>2 tools for process management</p>
                        <span class="badge">~150KB</span>
                    </div>
                </div>

                <h4>Common Build Profiles</h4>

                <h5>Minimal Coding Assistant (Filesystem + Terminal)</h5>
                <pre><code>cargo install --path . \
  --no-default-features \
  --features "filesystem,terminal"

# Smallest binary: ~1.2MB (vs 3.5MB full build)
# Perfect for: Basic file operations and command execution</code></pre>

                <h5>Thinking Agent (Filesystem + Sequential Thinking + Agents)</h5>
                <pre><code>cargo install --path . \
  --no-default-features \
  --features "filesystem,sequential_thinking,claude_agent"

# Medium binary: ~1.8MB
# Perfect for: Research, analysis, and multi-step reasoning</code></pre>

                <h5>Full-Featured Build (Default)</h5>
                <pre><code>cargo install --path .

# Complete binary: ~5.5MB
# Includes: All 75 tools across 11 categories</code></pre>

                <h3>Combining Compile-Time and Runtime Filtering</h3>
                <p>For maximum optimization, combine feature gates with runtime arguments:</p>

                <pre><code># 1. Build with only filesystem and terminal features
cargo install --path . \
  --no-default-features \
  --features "filesystem,terminal"

# 2. Configure MCP client to use only filesystem tools
{
  "mcpServers": {
    "kodegen": {
      "command": "kodegen",
      "args": ["--tool", "filesystem"]
    }
  }
}

# Result: Smallest binary + fastest startup + minimal memory footprint</code></pre>

                <h3>Checking Available Tools</h3>
                <p>List all tool categories compiled into your binary:</p>
                <pre><code>kodegen --list-categories</code></pre>

                <p>This shows which features were enabled at compile time.</p>

                <h3>Performance Comparison</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 2rem 0;">
                    <thead style="background: rgba(24, 202, 155, 0.2);">
                        <tr>
                            <th style="padding: 0.75rem; text-align: left; border: 1px solid rgba(24, 202, 155, 0.3);">Build Configuration</th>
                            <th style="padding: 0.75rem; text-align: left; border: 1px solid rgba(24, 202, 155, 0.3);">Binary Size</th>
                            <th style="padding: 0.75rem; text-align: left; border: 1px solid rgba(24, 202, 155, 0.3);">Startup Time</th>
                            <th style="padding: 0.75rem; text-align: left; border: 1px solid rgba(24, 202, 155, 0.3);">Memory Usage</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr style="background: rgba(255, 255, 255, 0.05);">
                            <td style="padding: 0.75rem; border: 1px solid rgba(24, 202, 155, 0.2);">Full Build (All Features)</td>
                            <td style="padding: 0.75rem; border: 1px solid rgba(24, 202, 155, 0.2);">~5.5MB</td>
                            <td style="padding: 0.75rem; border: 1px solid rgba(24, 202, 155, 0.2);">~30ms</td>
                            <td style="padding: 0.75rem; border: 1px solid rgba(24, 202, 155, 0.2);">~12MB</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.75rem; border: 1px solid rgba(24, 202, 155, 0.2);">Minimal (filesystem + terminal)</td>
                            <td style="padding: 0.75rem; border: 1px solid rgba(24, 202, 155, 0.2);">~1.2MB</td>
                            <td style="padding: 0.75rem; border: 1px solid rgba(24, 202, 155, 0.2);">~12ms</td>
                            <td style="padding: 0.75rem; border: 1px solid rgba(24, 202, 155, 0.2);">~4MB</td>
                        </tr>
                        <tr style="background: rgba(255, 255, 255, 0.05);">
                            <td style="padding: 0.75rem; border: 1px solid rgba(24, 202, 155, 0.2);">Filesystem Only</td>
                            <td style="padding: 0.75rem; border: 1px solid rgba(24, 202, 155, 0.2);">~900KB</td>
                            <td style="padding: 0.75rem; border: 1px solid rgba(24, 202, 155, 0.2);">~8ms</td>
                            <td style="padding: 0.75rem; border: 1px solid rgba(24, 202, 155, 0.2);">~3MB</td>
                        </tr>
                    </tbody>
                </table>

                <p><em>Note: Measurements are approximate and may vary by platform and usage patterns.</em></p>
            </section>

            <section id="tools" class="section">
                <h2>What Your Coding Agent Can Do</h2>
                <p>KODEGEN empowers LLM coding agents with 75 specialized tools. Here's what makes each category special:</p>

                <h3>üóÇÔ∏è Filesystem Tools (14 tools)</h3>

                <h4>üìñ Memory-Efficient File Reading</h4>
                <p><strong>What it enables:</strong> Your agent can read any file - from tiny configs to gigabyte-sized logs - without loading everything into memory.</p>
                <p><strong>Technical innovations:</strong></p>
                <ul>
                    <li><strong>Ring Buffer Streaming:</strong> Reading the last 100 lines of a 1GB file uses only ~10KB of memory thanks to VecDeque circular buffer implementation</li>
                    <li><strong>One-Pass Efficiency:</strong> Counts total lines while reading, not in a separate pass - O(n) instead of O(2n)</li>
                    <li><strong>Negative Offset Magic:</strong> Want the last 30 lines? Just specify offset: -30 and the agent gets tail behavior automatically</li>
                    <li><strong>Smart Image Handling:</strong> Automatically detects PNG, JPEG, GIF, WebP and returns base64-encoded data</li>
                    <li><strong>URL Support:</strong> Can fetch files from HTTP/HTTPS endpoints with 30-second timeout protection</li>
                    <li><strong>Helpful Annotations:</strong> Partial reads include headers like "[Reading lines 100-200 of 1000 total]"</li>
                </ul>

                <h4>‚úèÔ∏è Intelligent Code Editing</h4>
                <p><strong>What it enables:</strong> Surgical precision edits with automatic error recovery when exact matches fail.</p>
                <p><strong>Technical innovations:</strong></p>
                <ul>
                    <li><strong>Fuzzy Matching Fallback:</strong> When exact match fails, automatically tries fuzzy search with configurable similarity threshold (default: 0.8)</li>
                    <li><strong>Character-Level Diff Analysis:</strong> Shows exactly what's different with Unicode-aware character analysis</li>
                    <li><strong>Whitespace Detection:</strong> Identifies when differences are only whitespace (spaces vs tabs, CRLF vs LF)</li>
                    <li><strong>Line Ending Normalization:</strong> Automatically handles Windows (CRLF) vs Unix (LF) line endings</li>
                    <li><strong>Intelligent Error Messages:</strong> When fuzzy match found, displays character codes for invisible characters and suggests fixes</li>
                    <li><strong>Fire-and-Forget Logging:</strong> Async logging that never blocks execution, tracking all edit attempts for debugging</li>
                    <li><strong>Expected Count Validation:</strong> Warns if actual replacement count differs from expected</li>
                </ul>

                <h4>üîç Progressive Search</h4>
                <p><strong>What it enables:</strong> Stream search results as they're found instead of waiting for complete scan.</p>
                <ul>
                    <li><strong>Streaming Results:</strong> Get results progressively, cancel early when found what you need</li>
                    <li><strong>Regex Support:</strong> Full regular expression pattern matching across codebases</li>
                    <li><strong>Concurrent Traversal:</strong> Multi-threaded directory walking for faster results</li>
                </ul>

                <h4>üì¶ Batch Operations</h4>
                <p><strong>What it enables:</strong> Read multiple files in parallel, move/delete/create with atomic operations.</p>
                <ul>
                    <li><strong>Parallel Reading:</strong> <code>read_multiple_files</code> processes files concurrently</li>
                    <li><strong>Atomic Moves:</strong> Safe file relocation with validation</li>
                    <li><strong>Smart Metadata:</strong> <code>get_file_info</code> returns size, timestamps, permissions, line counts</li>
                </ul>

                <h3>üíª Terminal Tools (5 tools)</h3>

                <h4>üñ•Ô∏è Full Pseudoterminal Emulation</h4>
                <p><strong>What it enables:</strong> LLM agents can run commands exactly like you would in a terminal - builds, tests, interactive CLIs, anything.</p>
                <p><strong>Technical innovations:</strong></p>
                <ul>
                    <li><strong>True PTY Support:</strong> Full VT100 pseudoterminal implementation, not just command execution</li>
                    <li><strong>Smart State Detection:</strong> Automatically detects three states: command finished, still running, or waiting for REPL input</li>
                    <li><strong>REPL Recognition:</strong> Knows when interactive prompts (Python >>>, Node >, etc.) are ready for input</li>
                    <li><strong>Session Management:</strong> Track multiple running processes by PID, read output streams independently</li>
                    <li><strong>Output Streaming:</strong> Real-time output access for long-running builds without blocking</li>
                    <li><strong>Command Validation:</strong> Security layer blocks dangerous commands (rm -rf, sudo, etc.) with smart parsing</li>
                    <li><strong>Initial Delay Control:</strong> Configurable wait (default 100ms) for quick commands to complete before first response</li>
                </ul>

                <h4>üéØ Interactive Command Sessions</h4>
                <p><strong>What it enables:</strong> Your coding assistant can interact with REPLs, debuggers, and interactive CLIs just like a human developer.</p>
                <ul>
                    <li><strong>Send Input:</strong> Type into running sessions (Python REPL, database CLI, interactive installers)</li>
                    <li><strong>Read Output:</strong> Stream output in real-time as commands execute</li>
                    <li><strong>Stop Commands:</strong> Gracefully terminate long-running processes</li>
                    <li><strong>List Sessions:</strong> See all active terminal sessions with status</li>
                </ul>

                <h3>üß† Sequential Thinking (1 tool)</h3>

                <h4>üåä Stateful Reasoning Engine</h4>
                <p><strong>What it enables:</strong> Agents can break down complex problems across multiple reasoning steps, branch into parallel exploration, and revise thinking as insights emerge.</p>
                <p><strong>Technical innovations:</strong></p>
                <ul>
                    <li><strong>Actor-Model Concurrency:</strong> Each session runs in its own actor task with exclusive state ownership - completely lock-free!</li>
                    <li><strong>MPSC Message Passing:</strong> Commands sent via channels, zero shared memory contention</li>
                    <li><strong>Thought Branching:</strong> Explore multiple solution paths simultaneously - "What if we try REST vs GraphQL?"</li>
                    <li><strong>Revision Support:</strong> Mark thoughts as revising previous reasoning when new insights emerge</li>
                    <li><strong>Unlimited Context:</strong> Maintain complete thought history across extended problem-solving sessions</li>
                    <li><strong>Auto-Persistence:</strong> Orphaned sessions automatically saved to disk, cleaned up after 24 hours</li>
                    <li><strong>Colored Terminal Output:</strong> Thought streams rendered with syntax highlighting to stderr for debugging</li>
                    <li><strong>Auto-Termination:</strong> Session actor gracefully terminates when thinking is complete</li>
                </ul>

                <h3>üîÆ Agent Orchestration (5 tools)</h3>

                <h4>ü§ñ True N-Depth Agent Delegation</h4>
                <p><strong>What it enables:</strong> Agents can spawn specialized sub-agents, which can spawn their own sub-agents, creating hierarchical agent pyramids for complex tasks.</p>
                <p><strong>Why it's powerful:</strong></p>
                <ul>
                    <li><strong>Infinite Depth:</strong> No arbitrary limits - agents spawn agents spawn agents as deep as needed</li>
                    <li><strong>Custom Prompts:</strong> Full control over sub-agent instructions via prompt templates</li>
                    <li><strong>Real-Time Streaming:</strong> Watch sub-agent output as it generates, not after completion</li>
                    <li><strong>Parallel Execution:</strong> Spawn multiple specialist agents working on different aspects simultaneously</li>
                    <li><strong>Conversation Management:</strong> Send follow-up prompts, read responses, terminate when done</li>
                    <li><strong>Coordinated Workflows:</strong> Main agent orchestrates research agent + code generation agent + testing agent</li>
                </ul>

                <h3>üìù Prompt Management (4 tools)</h3>

                <h4>üé® Template Library with Jinja2</h4>
                <p><strong>What it enables:</strong> Agents can create, store, and reuse prompt templates with dynamic variable rendering.</p>
                <ul>
                    <li><strong>Jinja2 Rendering:</strong> Full template engine with variables, conditionals, loops</li>
                    <li><strong>Schema Validation:</strong> Ensure templates meet requirements before execution</li>
                    <li><strong>A/B Testing:</strong> Store multiple instruction variations and compare results</li>
                    <li><strong>Version Control Ready:</strong> Templates stored as files for git tracking</li>
                    <li><strong>CRUD Operations:</strong> Add, edit, delete, retrieve templates programmatically</li>
                </ul>

                <h3>üìä Introspection (2 tools)</h3>

                <h4>üîç Self-Observability</h4>
                <p><strong>What it enables:</strong> Agents can track their own behavior, analyze patterns, and optimize workflows.</p>
                <ul>
                    <li><strong>Usage Statistics:</strong> See which tools are called most, success rates, execution patterns</li>
                    <li><strong>Full Call History:</strong> Inspect recent invocations with complete arguments and responses</li>
                    <li><strong>Performance Metrics:</strong> Execution time tracking for bottleneck identification</li>
                    <li><strong>Failure Analysis:</strong> Spot recurring errors and debugging opportunities</li>
                    <li><strong>Self-Improvement:</strong> LLM agents can analyze their own tool usage to improve efficiency</li>
                </ul>

                <h3>‚öôÔ∏è Process & Configuration (4 tools)</h3>

                <h4>üîß System Control</h4>
                <p><strong>Process Management:</strong></p>
                <ul>
                    <li><strong>List Processes:</strong> View running system processes with CPU/memory stats and filtering</li>
                    <li><strong>Kill Process:</strong> Terminate processes by PID (with safety checks)</li>
                </ul>

                <p><strong>Runtime Configuration:</strong></p>
                <ul>
                    <li><strong>Get Config:</strong> Inspect current settings (line limits, thresholds, paths)</li>
                    <li><strong>Set Config:</strong> Modify behavior at runtime without restart (fuzzy search threshold, file limits, etc.)</li>
                    <li><strong>Dynamic Tuning:</strong> Agents can adjust their own configuration based on task requirements</li>
                </ul>

                <h3>üîó Git & GitHub (36 tools)</h3>
                <p><strong>Full Repository Operations:</strong> Complete git workflow automation plus GitHub API integration for issues, PRs, releases, and more. (Detailed tool list available in source code)</p>
            </section>

            <section id="examples" class="section">
                <h2>What Your Coding Agent Can Actually Do</h2>
                <p>Real-world workflows that autonomous agents can execute with KODEGEN:</p>

                <h3>üîÑ Autonomous Refactoring</h3>
                <p><strong>The Task:</strong> Convert synchronous functions to async throughout a Rust project.</p>
                <p><strong>What the agent does:</strong></p>
                <ol>
                    <li><strong>Search:</strong> Finds all function definitions matching the pattern across the entire codebase using streaming search</li>
                    <li><strong>Read:</strong> Opens each file to understand context and dependencies</li>
                    <li><strong>Edit:</strong> Makes surgical changes with fuzzy matching (handles whitespace variations automatically)</li>
                    <li><strong>Test:</strong> Runs cargo test in a terminal session, monitoring output in real-time</li>
                    <li><strong>Validate:</strong> Checks test output, rolls back if failures detected</li>
                    <li><strong>Commit:</strong> Creates git commit when all tests pass</li>
                </ol>
                <p><strong>Why it works:</strong> Memory-efficient file reading means the agent can process massive codebases. Fuzzy matching recovers from minor mismatches. Terminal state detection knows exactly when tests finish.</p>

                <h3>üïµÔ∏è Multi-Agent Code Analysis</h3>
                <p><strong>The Task:</strong> Research best practices and generate production-ready error handling code.</p>
                <p><strong>What happens:</strong></p>
                <ol>
                    <li><strong>Main Agent:</strong> Spawns a research specialist sub-agent with custom prompt: "Research Rust async error handling patterns in 2024"</li>
                    <li><strong>Research Agent:</strong> Searches web, analyzes documentation, compiles findings into structured report</li>
                    <li><strong>Main Agent:</strong> Spawns code generation specialist with findings from research agent</li>
                    <li><strong>Code Agent:</strong> Generates example implementations following discovered best practices</li>
                    <li><strong>Main Agent:</strong> Reviews output from both sub-agents, synthesizes final implementation</li>
                </ol>
                <p><strong>Why it works:</strong> N-depth delegation allows specialization. Real-time streaming means main agent sees progress. Each sub-agent can spawn its own helpers if needed.</p>

                <h3>üèóÔ∏è Architectural Design with Branching Thought</h3>
                <p><strong>The Task:</strong> Design a scalable API architecture with exploration of alternatives.</p>
                <p><strong>The reasoning process:</strong></p>
                <ol>
                    <li><strong>Initial Analysis:</strong> "Need to design a scalable API layer - considering performance, maintainability, team expertise"</li>
                    <li><strong>Branch A:</strong> Explores REST API approach - analyzes versioning strategies, caching benefits, tooling ecosystem</li>
                    <li><strong>Branch B:</strong> Explores GraphQL approach - analyzes federation patterns, over-fetching elimination, learning curve</li>
                    <li><strong>Synthesis:</strong> Compares branches, discovers REST better fits due to caching requirements and team experience</li>
                    <li><strong>Revision:</strong> Updates initial architecture decision with evidence from both branches</li>
                </ol>
                <p><strong>Why it works:</strong> Lock-free actor model means zero contention even with many branches. Auto-persistence means long planning sessions never lose progress. Revision support allows refinement as understanding deepens.</p>

                <h3>üöÄ Full-Stack Feature Implementation</h3>
                <p><strong>The Task:</strong> Add authentication to an existing web application.</p>
                <p><strong>End-to-end automation:</strong></p>
                <ol>
                    <li><strong>Planning:</strong> Uses sequential thinking to break down requirements into implementation steps</li>
                    <li><strong>Research:</strong> Spawns sub-agent to research OAuth 2.0 best practices and security considerations</li>
                    <li><strong>Database:</strong> Edits migration files, runs migrations via terminal, validates schema changes</li>
                    <li><strong>Backend:</strong> Searches for route definitions, adds auth middleware with fuzzy-matched edits, implements JWT handling</li>
                    <li><strong>Frontend:</strong> Adds login UI components, updates API client with auth headers</li>
                    <li><strong>Testing:</strong> Runs unit tests in parallel terminal sessions, monitors output streams</li>
                    <li><strong>Integration:</strong> Spawns test agent to write E2E tests covering auth flows</li>
                    <li><strong>Documentation:</strong> Updates README with auth setup instructions</li>
                    <li><strong>Review:</strong> Uses introspection tools to analyze what tools were used most, optimize future implementations</li>
                </ol>
                <p><strong>Why it works:</strong> The combination of all 75 tools creates truly autonomous capability. File operations handle code changes, terminal tools run tests/migrations, agent orchestration delegates specialized tasks, sequential thinking maintains coherent strategy across hundreds of steps.</p>
            </section>

            <section id="contributing" class="section">
                <h2>Contributing</h2>

                <p>KODEGEN.·¥Ä…™ is open source and welcomes contributions!</p>

                <h3>Getting Started</h3>
                <ol>
                    <li>Fork the repository on <a href="https://github.com/cyrup-ai/kodegen" target="_blank">GitHub</a></li>
                    <li>Clone your fork: <code>git clone https://github.com/YOUR_USERNAME/kodegen.git</code></li>
                    <li>Create a feature branch: <code>git checkout -b feature/amazing-tool</code></li>
                    <li>Make your changes</li>
                    <li>Run tests: <code>cargo test</code></li>
                    <li>Commit and push: <code>git push origin feature/amazing-tool</code></li>
                    <li>Open a Pull Request</li>
                </ol>

                <h3>Development Guidelines</h3>
                <ul>
                    <li>All tools must implement the <code>Tool</code> trait</li>
                    <li>Follow the pattern in <code>packages/filesystem/src/read_file.rs</code></li>
                    <li>Write comprehensive prompts for LLM learning</li>
                    <li>Add JsonSchema to all Args types</li>
                    <li>Update documentation when adding features</li>
                </ul>

                <h3>Community</h3>
                <p>Join the discussion:</p>
                <ul>
                    <li><a href="https://github.com/cyrup-ai/kodegen" target="_blank">GitHub Repository</a></li>
                    <li><a href="https://github.com/kodegen" target="_blank">kodegen.ai Organization</a></li>
                </ul>
            </section>
        </main>
    </div>

    <div class="hero-section">
        <video autoplay muted loop playsinline class="kodegen-video">
            <source src="../assets/cyrup_oceanic.mp4" type="video/mp4">
        </video>
    </div>

    <div class="footer">
        <p>
            <a href="https://github.com/cyrup-ai/kodegen" target="_blank">GitHub</a> ‚Ä¢
            <a href="../index.html">Home</a> ‚Ä¢
            <a href="https://github.com/kodegen" target="_blank">kodegen.ai</a>
        </p>
        <p style="margin-top: 1rem;">
            Made with (love) by <a href="https://www.linkedin.com/in/davemaple/" target="_blank">David Maple</a>
        </p>
    </div>
</body>
</html>
